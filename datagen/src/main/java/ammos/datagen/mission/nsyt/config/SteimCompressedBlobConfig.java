/*
 * Copyright 2006-2018. California Institute of Technology.
 * ALL RIGHTS RESERVED.
 * U.S. Government sponsorship acknowledged.
 *
 * This software is subject to U. S. export control laws and
 * regulations (22 C.F.R. 120-130 and 15 C.F.R. 730-774). To the
 * extent that the software is subject to U.S. export control laws
 * and regulations, the recipient has the responsibility to obtain
 * export licenses or other export authority as may be required
 * before exporting such information to foreign countries or
 * providing access to foreign nationals.
 */
package ammos.datagen.mission.nsyt.config;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;

import ammos.datagen.config.InvalidConfigurationException;
import jpl.gds.shared.gdr.GDR;
import jpl.gds.shared.log.TraceManager;
import jpl.gds.shared.log.Tracer;
import jpl.gds.shared.sys.SystemUtilities;

/**
 * Encapsulates the interface to a Steim-Lite compressed blob configuration file
 * for NSYT. Compressed blobs are used to populate continuous science packets to
 * simulate those generated by the SEIS and APSS instruments. The compressed
 * blob configuration is a properties file that both points to the actual blob
 * file, but also identifies aspects of the blob that are required to place them
 * into packets. This class is also capable of loading both the blob data and
 * the associated truth data.
 * 
 * 
 *
 */
public class SteimCompressedBlobConfig {

	private static final String BLOB_FILE_NAME = "blob.dataFile";
	private static final String TRUTH_FILE_NAME = "blob.truthFile";
	private static final String MOMENTS = "blob.moments";
	private static final String FIRST_SAMPLE = "blob.firstSampleValue";
	private static final String LAST_SAMPLE = "blob.lastSampleValue";
	private static final String NUMBER_OF_DELTAS = "blob.numDeltas";
	private static final String CHANNEL_ID_LIST = "blob.channelIds";

	private static final Tracer log = TraceManager.getDefaultTracer();


	private final String propertyFileName;
	private final Properties properties = new Properties();
	private byte[] blob;
	private List<Integer> truthValues;

	/**
	 * Constructor. Instance remains useless until load() is invoked.
	 * 
	 * @param filePath
	 *            the property file path name
	 */
	public SteimCompressedBlobConfig(final String filePath) {
		this.propertyFileName = filePath;
	}

	/**
	 * Loads the properties files into the local property table. Clears the
	 * property table first.
	 * 
	 * @param validate
	 *            true if file contents should be validated, and blob and truth
	 *            content loaded; false to just load the properties
	 * 
	 * @return true if the file was loaded, false if not
	 */
	public synchronized boolean load(final boolean validate) {

		boolean loaded = false;

		this.properties.clear();
		this.blob = null;
		this.truthValues = null;

		final File propFile = new File(this.propertyFileName);

		if (propFile.exists()) {
			try {
				this.properties.load(new FileReader(propFile));
				log.info("Loaded compressed blob properties from "
						+ propFile.getPath());
				loaded = true;
			} catch (final IOException e) {
				log.error("I/O error loading " + propFile.getPath());
			}
		} else {
			log.error("Compressed blob properties file "
					+ this.propertyFileName + " not found.");
		}

		log.debug("Contents of compressed blob configuration: "
				+ this.properties);

		/*
		 * If validate is turned on, the act of fetching all the properties via
		 * their getters will cause any configuration errors to be uncovered.
		 */
		if (loaded && validate) {
			try {
				getChannelIdList();
				getBlobDataFile();
				getBlobTruthFile();
				getFirstSampleValue();
				getLastSampleValue();
				getNumberOfDeltas();
				getMoments();
				getBlob();
				getTruthValues();
			} catch (final InvalidConfigurationException e) {
				log.error(e.getMessage());
				loaded = false;
			}
		}

		return loaded;
	}

	/**
	 * Get the list of instrument channels IDs for which this blob may be used.
	 * If no channel IDs are defined in the properties file, it is assumed that
	 * the blob can be used for packets that contain any instrument channel ID.
	 * 
	 * @return List of IDs, or null if none configured.
	 * @throws InvalidConfigurationException
	 *             if there is any problem parsing the channel ID list
	 */
	public List<Integer> getChannelIdList()
			throws InvalidConfigurationException {

		return getUnsignedIntegerList(CHANNEL_ID_LIST);
	}

	/**
	 * Gets the path to the blob data file. This file contains a compressed blob
	 * of bytes to be written to a packet. The path can be specified in the
	 * properties file as either an absolute path, or a path relative to the
	 * "config" directory.
	 * 
	 * @return file path to the blob data file
	 * @throws InvalidConfigurationException
	 *             if the blob file is not found or not configured
	 */
	public String getBlobDataFile() throws InvalidConfigurationException {
		final String file = getFileOrDirProperty(BLOB_FILE_NAME);
		if (file == null) {
			throw new InvalidConfigurationException(
					"Unspecified or invalid blob data file configured by property "
							+ BLOB_FILE_NAME + " in file "
							+ this.propertyFileName);
		}
		return file;
	}

	/**
	 * Gets the path to the blob truth file. This is an ASCII file that contains
	 * unsigned integer sample values, 1 per line, that describe the
	 * uncompressed sample content of the blob. A truth file is optional. The
	 * path can be specified in the properties file as either an absolute path,
	 * or a path relative to the "config" directory. A warning will be issued if
	 * a truth file is configured but cannot be found.
	 * 
	 * @return file path to the blob truth file, or null if none configured or
	 *         the file is not found
	 */
	public String getBlobTruthFile() {
		final String file = getFileOrDirProperty(TRUTH_FILE_NAME);
		if (file == null
				&& this.properties.getProperty(TRUTH_FILE_NAME) != null) {
			log.warn("Truth file was configured in properties file "
					+ this.propertyFileName + " but the file was not found");
		}
		return file;
	}

	/**
	 * Gets the unsigned integer value of the first sample in the compressed
	 * blob. The uncompressed value of the first sample is necessary in the
	 * packet in order to instigate decompression.
	 * 
	 * @return the configured first sample value, unsigned
	 * 
	 * @throws InvalidConfigurationException
	 *             if there is problem parsing the configured value or the value
	 *             is not configured
	 */
	public int getFirstSampleValue() throws InvalidConfigurationException {
		return getUnsignedIntProperty(FIRST_SAMPLE);
	}

	/**
	 * Gets the unsigned integer value of the last sample in the compressed
	 * blob.
	 * 
	 * @return the configured last sample value, unsigned
	 * 
	 * @throws InvalidConfigurationException
	 *             if there is problem parsing the configured value or the value
	 *             is not configured
	 */
	public int getLastSampleValue() throws InvalidConfigurationException {
		return getUnsignedIntProperty(LAST_SAMPLE);
	}

	/**
	 * Gets the number of deltas in the compressed blob.
	 * 
	 * @return the configured number of deltas, unsigned
	 * 
	 * @throws InvalidConfigurationException
	 *             if there is problem parsing the configured value or the value
	 *             is not configured
	 */
	public int getNumberOfDeltas() throws InvalidConfigurationException {
		return getUnsignedIntProperty(NUMBER_OF_DELTAS);
	}

	/**
	 * Gets the configured compression moments; these values are required for
	 * blob decompression.
	 * 
	 * @return list of 4 unsigned integer moments between 0 and 255
	 * @throws InvalidConfigurationException
	 *             if there is a problem parsing the moments from the
	 *             configuration
	 */
	public List<Integer> getMoments() throws InvalidConfigurationException {
		final List<Integer> result = getUnsignedIntegerList(MOMENTS);

		if (result == null) {
			throw new InvalidConfigurationException(MOMENTS
					+ " property not found in properties file "
					+ this.propertyFileName);
		}

		if (result.size() != 4) {
			throw new InvalidConfigurationException(
					MOMENTS
							+ " property does not have exactly 4 values in properties file "
							+ this.propertyFileName);
		}

		for (final int val : result) {
			if (val < 0 || val > 255) {
				throw new InvalidConfigurationException(
						MOMENTS
								+ " property has a value that is not between 0 and 255 in properties file "
								+ this.propertyFileName);
			}
		}
		return result;
	}

	/**
	 * Gets the actual compressed data blob from the blob file. The first time
	 * this method is invoked, the blob file is read and the data is cached.
	 * 
	 * @return array if bytes containing the blob
	 * @throws InvalidConfigurationException
	 *             if the blob data file is mis-configured or if there is a
	 *             problem reading the blob file
	 */
	public synchronized byte[] getBlob() throws InvalidConfigurationException {

		/* The blob is cached. No sense reading it every time. */
		if (this.blob != null) {
			return this.blob;
		}

		/* Not cached yet. Read the file. */
		FileInputStream fis = null;
		try {
			/*
			 * We read the whole blob into the a byte array that is the same
			 * length as the file.
			 */
			final File blobFile = new File(getBlobDataFile());
			fis = new FileInputStream(blobFile);
			this.blob = new byte[(int) blobFile.length()];
			fis.read(this.blob);
			fis.close();

		} catch (final IOException e) {
			throw new InvalidConfigurationException(
					"Loading of blob data failed: " + e.toString(), e);
		} finally {
			if (fis != null) {
				try {
					fis.close();
				} catch (final IOException e) {
					SystemUtilities.doNothing();
				}
			}
		}

		return this.blob;

	}

	/**
	 * Returns the list of truth values (the expected sample values) for this
	 * blob. The first time this is invoked, it reads the file and caches the
	 * information.
	 * 
	 * @return List of unsigned integer truth values; will be null if there is
	 *         no truth file
	 * @throws InvalidConfigurationException
	 *             if the truth file is mis-configured or there is a problem
	 *             reading the truth file
	 */
	public synchronized List<Integer> getTruthValues()
			throws InvalidConfigurationException {
		if (this.truthValues != null) {
			return this.truthValues;
		}
		final String truthFilePath = getBlobTruthFile();
		if (truthFilePath == null) {
			return null;
		}
		final File truthFile = new File(truthFilePath);
		BufferedReader br = null;
		try {
			/*
			 * Truth values are unsigned 24-bit values, one per line. Read them
			 * into the truth list.
			 */
			br = new BufferedReader(new FileReader(truthFile));

			this.truthValues = new LinkedList<Integer>();
			String line = br.readLine();
			while (line != null) {
				line = line.trim();
				if (!line.trim().isEmpty()) {
					final int val = GDR.parse_int(line);
					this.truthValues.add(val);
				}
				line = br.readLine();
			}

			br.close();
		} catch (final NumberFormatException | IOException e) {
			throw new InvalidConfigurationException(
					"Loading of truth data failed: " + e.toString(), e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (final IOException e) {
					SystemUtilities.doNothing();
				}
			}
		}

		/*
		 * The number of truth values had better match the number of samples,
		 * which is deltas + 1
		 */
		if (this.truthValues.size() != getNumberOfDeltas() + 1) {
			throw new InvalidConfigurationException(
					"Loading of truth data failed because the number of deltas + 1 does not match the number of truth samples ("
							+ this.truthValues.size() + ")");
		}

		return this.truthValues;

	}

	/**
	 * Common utility method to gets the path to the file or directory specified
	 * by the given configuration property. In general, the file or directory
	 * should be specified in the properties file with NO path, and will then be
	 * searched for in the same directory as the current properties file. If it
	 * has an absolute path, then that is the file path that will be returned.
	 * 
	 * @return file path, or null if not configured or configured file does not
	 *         exist.
	 */
	private String getFileOrDirProperty(final String propertyName) {
		String filename = this.properties.getProperty(propertyName);
		if (filename == null) {
			return null;
		}
		if (!filename.startsWith(File.separator)) {
			filename = new File(this.propertyFileName).getParent()
					+ File.separator + filename;
		}
		if (filename != null) {
			if (!new File(filename).exists()) {
				filename = null;
			}
		}
		return filename;
	}

	/**
	 * A common utility method for reading an unsigned integer configuration
	 * property.
	 * 
	 * @param propertyName
	 *            the name of the property
	 * @return the unsigned integer value of the property
	 * @throws InvalidConfigurationException
	 *             if the property is not configured, is not an integer, or is <
	 *             0.
	 */
	private int getUnsignedIntProperty(final String propertyName)
			throws InvalidConfigurationException {
		int val = -1;
		final String valStr = this.properties.getProperty(propertyName);
		if (valStr != null) {
			try {
				val = GDR.parse_int(valStr);
			} catch (final NumberFormatException e) {
				SystemUtilities.doNothing();
			}
		}
		if (val < 0) {
			throw new InvalidConfigurationException(
					"Invalid or missing value (" + valStr
							+ ") for blob property " + propertyName
							+ " in file " + this.propertyFileName);
		}
		return val;
	}

	/**
	 * Utility method to parse a comma-separated list of unsigned integer values
	 * from the properties file.
	 * 
	 * @param propertyName
	 *            the name of the list property to parse
	 * @return a list of unsigned integers; may be empty, but will not be null
	 * 
	 * @throws InvalidConfigurationException
	 *             if there is any problem parsing the property value
	 */
	private List<Integer> getUnsignedIntegerList(final String propertyName)
			throws InvalidConfigurationException {

		final String ids = this.properties.getProperty(propertyName);
		final List<Integer> result = new LinkedList<Integer>();
		if (ids != null && !ids.isEmpty()) {
			final String[] pieces = ids.split(",");
			for (final String next : pieces) {
				try {
					final int val = Integer.parseInt(next.trim());
					if (val < 0) {
						throw new InvalidConfigurationException(
								"Found negative unsigned integer value (" + val
										+ ") reading " + propertyName
										+ " from properties file "
										+ this.propertyFileName);

					}
					result.add(val);
				} catch (final NumberFormatException e) {
					throw new InvalidConfigurationException(
							"Found invalid unsigned integer value ("
									+ next.trim() + ") reading " + propertyName
									+ " from properties file "
									+ this.propertyFileName, e);
				}
			}
		}
		return result;
	}
}
