/*
 * Copyright 2006-2018. California Institute of Technology.
 * ALL RIGHTS RESERVED.
 * U.S. Government sponsorship acknowledged.
 *
 * This software is subject to U. S. export control laws and
 * regulations (22 C.F.R. 120-130 and 15 C.F.R. 730-774). To the
 * extent that the software is subject to U.S. export control laws
 * and regulations, the recipient has the responsibility to obtain
 * export licenses or other export authority as may be required
 * before exporting such information to foreign countries or
 * providing access to foreign nationals.
 */
package jpl.gds.evr.impl;

import jpl.gds.dictionary.api.evr.IEvrDefinition;
import jpl.gds.evr.api.EvrMetadata;
import jpl.gds.evr.api.EvrMetadataKeywordEnum;
import jpl.gds.evr.api.IEvr;
import jpl.gds.shared.holders.PacketIdHolder;
import jpl.gds.shared.time.IAccurateDateTime;
import jpl.gds.shared.time.ILocalSolarTime;
import jpl.gds.shared.time.ISclk;
import jpl.gds.shared.time.TimeUtility;
import jpl.gds.shared.types.Pair;

import java.text.DateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Common, multi-mission representation of an EVR object, that implements the
 * <code>IEvr</code> interface.
 *
 *
 * @see IEvr
 * 
 */
public class Evr implements IEvr
{
    private IEvrDefinition evrDefinition;

    private boolean realtime;
    private String message = "";	// Message must never be null
    private ISclk sclk;
    private IAccurateDateTime scet;
    private IAccurateDateTime ert;
    private ILocalSolarTime sol;
    private IAccurateDateTime rct;
    private int dssId = 0; //  Unspecified dss id must be 0.
    private Integer vcid = null;
    private PacketIdHolder packetId = PacketIdHolder.UNSUPPORTED;
    /** Indicates the current EVR is invalid. */
    protected boolean isBad = false;

    private final EvrMetadata metadata;

    /**
     * True if this EVR was generated by the SSE, false if it
     * was generated by FSW (or some other entity)
     */
    protected boolean fromSse;

    /**
     * Creates an instance of Evr.
     */
    public Evr()
    {
        metadata = new EvrMetadata();
    }

    /**
     * Default constructor.
     * 
     * @param evrDef
     *            definition from the EVR dictionary for the new EVR object
     * @param scet
     *            SCET value of the EVR
     * @param ert
     *            ERT value of the EVR
     * @param rct
     *            RCT value of the EVR
     * @param sclk
     *            SCLK value of the EVR
     * @param sol
     *            SOL value of the EVR (local solar time)
     * @param message
     *            EVR message (formatted EVR content)
     * @param metadata
     *            EVR metadata
     * @param fromSse
     *            true if EVR's source is SSE, false otherwise (i.e. FSW)
     * @param dssId
     *            station ID for this EVR
     * @param vcid
     *            virtual channel ID for this EVR
     */
    /* 
     * Changed AbstractEvrDefinition to IEvrDefinition
     * in support of the Global LAD implementation, since EvrDefinitionTable returns IEvrDefinition
     * Also a good idea to use the interface rather than the abstract class.
     * It seems to be a safe change after unit testing.
     */
    public Evr(final IEvrDefinition evrDef, final IAccurateDateTime scet,
            final IAccurateDateTime ert, final IAccurateDateTime rct, final ISclk sclk,
            final ILocalSolarTime sol, final String message,
            final EvrMetadata metadata, final boolean fromSse,
            final int    dssId,
            final Integer vcid)
    {
        evrDefinition = evrDef;
        this.scet = scet;
        this.ert = ert;
        this.rct = rct;
        this.sclk = sclk;
        this.sol = sol;
        this.message = message;
        this.metadata = new EvrMetadata(metadata);
        this.fromSse = fromSse;
        this.dssId   = dssId;
        this.vcid    = vcid;
    }


    /**
     * {@inheritDoc}
     * @see jpl.gds.shared.template.Templatable#setTemplateContext(java.util.Map)
     */
    @Override
    public void setTemplateContext(final Map<String,Object> map) {
        final DateFormat df = TimeUtility.getFormatterFromPool();

        if (evrDefinition == null ) {
            map.put("module", "");
            map.put("level", "");
            map.put("opscat", "");
            map.put("name","");
            map.put("event", (long) 0);    	
        }
        else {
            if (evrDefinition.getCategory(IEvrDefinition.MODULE) != null) {
                map.put("module", evrDefinition.getCategory(IEvrDefinition.MODULE));
            } else {
                map.put("module", "");
            }
            if (evrDefinition.getLevel() != null) {
                map.put("level", evrDefinition.getLevel());
            } else {
                map.put("level", "");
            }
            if (evrDefinition.getCategory(IEvrDefinition.OPS_CAT) != null) {
                map.put("opscat", evrDefinition.getCategory(IEvrDefinition.OPS_CAT));
            } else {
                map.put("opscat", "");
            }
            if(evrDefinition.getName() != null)
            {
                map.put("name",evrDefinition.getName());
            }
            else
            {
                map.put("name","");
            }

            map.put("event", evrDefinition.getId());
        }

        if (message != null) {
            map.put("message", message);
        } else {
            map.put("message", "");
        }
        map.put("realTime", (realtime ? "true" : "false"));
        if (sclk != null) {
            map.put("sclk", sclk);
            map.put("sclkCoarse",sclk.getCoarse());
            map.put("sclkFine",sclk.getFine());
            map.put("sclkExact",sclk.getBinaryGdrLong());
        } else {
            map.put("sclk", "");
            map.put("sclkCoarse",0);
            map.put("sclkFine",0);
            map.put("sclkExact",0);
        }
        if (scet != null) {
            map.put("scet", scet.getFormattedScet(true));
            map.put("scetExact", scet.getTime());
            map.put("scetExactFine", scet.getNanoseconds());
        } else {
            map.put("scet", "");
            map.put("scetExact",0);
            map.put("scetExactFine",0);
        }
        if (ert != null) {
            map.put("ert", ert.getFormattedErt(true));
            map.put("ertExact", ert.getTime());
            map.put("ertExactFine",ert.getNanoseconds());
        } else {
            map.put("ert", "");
            map.put("ertExact",0);
            map.put("ertExactFine",0);
        }
        if (sol != null) {
            map.put("lst", sol.getFormattedSol(true));
            map.put("lstExact", sol.getTime());
            map.put("lstExactFine",sol.getSolNumber());
        } else {
            map.put("lst", "");
            map.put("lstExact",0);
            map.put("lstExactFine",0);
        }

        if (rct != null) {
            map.put("rct", df.format(rct));
            map.put("rctExact", rct.getTime());
        } else {
            map.put("rct", "");
            /*  Added missing setting of rctExact in map */
            map.put("rctExact", 0);
        }
        map.put("fromSse", fromSse);

        //null value is checked in velocity template
        map.put("vcid", vcid);
        map.put("dssId", dssId > 0 ? dssId : 0); // -1 is unknown, but to match the output with database, setting it to 0 if unknown

        // Metadata

        if (! metadata.isEmpty())
        {
            final List<Pair<EvrMetadataKeywordEnum, String>> keyvalues =
                    metadata.asStrings();

            final ArrayList<EvrMetadataKeywordEnum> mdKeys =
                    new ArrayList<EvrMetadataKeywordEnum>();
            final ArrayList<String>    mdVals = new ArrayList<String>();
            Pair<EvrMetadataKeywordEnum, String> next = keyvalues.get(0);

            StringBuilder mdKeysList = new StringBuilder("[" + "(" + next.getOne() + ")");
            StringBuilder mdValsList = new StringBuilder("[" + "(" + next.getTwo() + ")");

            mdKeys.add(next.getOne());
            mdVals.add(next.getTwo());

            for (int i = 1; i < keyvalues.size(); ++i)
            {
                next = keyvalues.get(i);

                mdKeysList = mdKeysList.append(",(" + next.getOne() + ")");
                mdValsList = mdValsList.append(",(" + next.getTwo() + ")");

                mdKeys.add(next.getOne());
                mdVals.add(next.getTwo());
            }

            mdKeysList.append("]");
            mdValsList.append("]");

            map.put("mdKeysList",mdKeysList.toString());
            map.put("mdValsList",mdValsList.toString());
            map.put("metadataKeys", mdKeys);
            map.put("metadataVals", mdVals);
        }
        else
        {
            map.put("mdKeysList","");
            map.put("mdValsList","");
            map.put("metadataKeys", new ArrayList<String>());
            map.put("metadataVals", new ArrayList<String>());
        }

        map.put("isBad", isBad ? "true" : "false");

        TimeUtility.releaseFormatterToPool(df);
  
    }


    /**
     * {@inheritDoc}
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString()
    {
        final StringBuilder s = new StringBuilder();

        // type
        s.append("<evr");

        if (evrDefinition != null)
        {    	
            if (evrDefinition.getCategory(IEvrDefinition.MODULE) != null) {
                s.append(" task=\"");
                s.append(evrDefinition.getCategory(IEvrDefinition.MODULE));
                s.append("\"");
            }

            if (evrDefinition.getLevel() != null) {
                s.append(" level=\"");
                s.append(evrDefinition.getLevel());
                s.append("\"");
            }

        }
        s.append(">\n");

        // message
        s.append("  <message");

        if (evrDefinition != null ) {
            s.append(" id=\"");
            s.append(evrDefinition.getId());
            s.append("\"");

            if(evrDefinition.getName() != null) {
                s.append(" name=\"");
                s.append(evrDefinition.getName());
                s.append("\"");
            }
        }
        s.append("><![CDATA[");
        s.append(message);
        s.append("]]></message>\n");

        // times
        s.append("  <time realtime=\"");
        s.append(realtime ? "yes" : "no");
        s.append("\">\n");
        if (sclk != null) {
            s.append("    <sclk>");
            s.append(sclk.toString());
            s.append("</sclk>\n");
        }
        if (scet != null) {
            s.append("    <scet>");
            s.append(scet.toString());
            s.append("</scet>\n");
        }
        if (sol != null) {
            s.append("    <sol>");
            s.append(sol.toString());
            s.append("</sol>\n");
        }
        if (ert != null) {
            s.append("    <ert>");
            s.append(ert.toString());
            s.append("</ert>\n");
        }
        if (rct != null) {
            s.append("    <rct>");
            s.append(rct.toString());
            s.append("</rct>\n");
        }
        s.append("  </time>\n");

        // Metadata

        if (! metadata.isEmpty())
        {
            s.append("  <metadata>\n");

            for (final Pair<EvrMetadataKeywordEnum, String> p :
                metadata.asStrings())
            {
                s.append("    <value key=\"");
                s.append(p.getOne().toString());
                s.append("\"><![CDATA[");
                s.append(p.getTwo());
                s.append("]]></value>\n");
            }

            s.append("  </metadata>\n");
        }

        s.append("</evr>\n");

        return s.toString();
    }
    

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getErt()
     */
    @Override
    public IAccurateDateTime getErt() {
        return ert;
    }

    /**
     * {@inheritDoc}
     *
     * @see jpl.gds.evr.api.IEvr#setErt(jpl.gds.shared.time.IAccurateDateTime)
     */
    @Override
    public void setErt(final IAccurateDateTime ert) {
        this.ert = ert;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getEventId()
     */
    @Override
    public long getEventId() {
        if (evrDefinition != null) {
            return evrDefinition.getId();
        }
        else {
            return 0;
        }
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getLevel()
     */
    @Override
    public String getLevel() {
        if (evrDefinition != null) {
            return evrDefinition.getLevel();  		
        }
        else {
            return null;
        }
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getMessage()
     */
    @Override
    public String getMessage() {
        return message;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setMessage(java.lang.String)
     */
    @Override
    public void setMessage(final String message) {
        this.message = message;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getMetadata()
     */
    @Override
    public EvrMetadata getMetadata()
    {
        return metadata;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getMetadataKeyValueStrings()
     */
    @Override
    public List<Pair<EvrMetadataKeywordEnum, String>>
    getMetadataKeyValueStrings()
    {
        return metadata.asStrings();
    }


    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setMetadataKeyValuesFromStrings(List, List)
     */
    @Override
    public void setMetadataKeyValuesFromStrings(
            final List<EvrMetadataKeywordEnum> keys,
            final List<String> values)
    {
        metadata.clear();

        final int ksize = (keys   != null) ? keys.size()   : 0;
        final int vsize = (values != null) ? values.size() : 0;
        final int size  = Math.max(ksize, vsize);

        for (int i = 0; i < size; ++i)
        {
            metadata.addKeyValue((i < ksize) ? keys.get(i)   : null,
                    (i < vsize) ? values.get(i) : null);
        }
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getMetadataValue(jpl.gds.evr.api.EvrMetadataKeywordEnum)
     */
    @Override
    public String getMetadataValue(final EvrMetadataKeywordEnum key)
    {
        return metadata.getMetadataValue(key);
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getRct()
     */
    @Override
    public IAccurateDateTime getRct() {
        return rct;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setRct(java.util.Date)
     */
    @Override
    public void setRct(final IAccurateDateTime rct) {
        this.rct = rct;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#isRealtime()
     */
    @Override
    public boolean isRealtime() {
        return realtime;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setRealtime(boolean)
     */
    @Override
    public void setRealtime(final boolean realtime) {
        this.realtime = realtime;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getScet()
     */
    @Override
    public IAccurateDateTime getScet() {
        return scet;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setScet(jpl.gds.shared.time.IAccurateDateTime)
     */
    @Override
    public void setScet(final IAccurateDateTime scet) {
        this.scet = scet;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getSol()
     */
    @Override
    public ILocalSolarTime getSol() {
        return sol;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setSol(jpl.gds.shared.time.ILocalSolarTime)
     */
    @Override
    public void setSol(final ILocalSolarTime sol) {
        this.sol = sol;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getSclk()
     */
    @Override
    public ISclk getSclk() {
        return sclk;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setSclk(jpl.gds.shared.time.Sclk)
     */
    @Override
    public void setSclk(final ISclk sclk) {
        this.sclk = sclk;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#isBadEvr()
     */
    @Override
    public boolean isBadEvr()
    {
        return isBad;
    }
    
    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#isFromSse()
     */
    @Override
    public boolean isFromSse()
    {
        return fromSse;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setFromSse(boolean)
     */
    @Override
    public void setFromSse(final boolean fromSse)
    {
        this.fromSse = fromSse;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setBadEvr(boolean)
     */
    @Override
    public void setBadEvr(final boolean status)
    {
        this.isBad = status;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getName()
     */
    @Override
    public String getName()
    {
        if (evrDefinition != null) {
            return (evrDefinition.getName());
        }
        else {
            return null;
        }
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#getEvrDefinition()
     */
    @Override
    public IEvrDefinition getEvrDefinition()
    {
        return evrDefinition;
    }

    /**
     * {@inheritDoc}
     * 
     * @see jpl.gds.evr.api.IEvr#setEvrDefinition(jpl.gds.dictionary.impl.impl.api.evr.IEvrDefinition)
     */
    @Override
    public void setEvrDefinition(final IEvrDefinition evrDef) {
        evrDefinition = evrDef;
    }


    /**
     * Gets the DSS (receiving station) ID for this channel value.
     *
     * @return the DSS ID; 0 for no station
     */
    @Override
    public int getDssId()
    {
        return dssId;
    }


    /**
     * Sets the DSS (receiving station) ID for this channel value.
     * @param dss the DSS ID; 0 for no station
     */
    @Override
    public void setDssId(final int dss)
    {
        dssId = dss;
    }


    /**
     * Gets the VCID (virtual channel id) for this channel value.
     * @return the VCID; null for unknown
     */
    @Override
    public Integer getVcid()
    {
        return vcid;
    }


    /**
     * Sets the VCID (virtual channel id) for this channel value.
     * @param vcid null for unknown
     */
    @Override
    public void setVcid(final Integer vcid)
    {
        this.vcid = vcid;
    }


    /**
     * Gets the packet id for this channel value.
     *
     * @return the packet id; null for unknown
     */
    @Override
    public PacketIdHolder getPacketId()
    {
        return packetId;
    }


    /**
     * Sets the packet id for this channel value.
     *
     * @param packetId Packet id, null for unknown
     */
    @Override
    public void setPacketId(final PacketIdHolder packetId)
    {
        this.packetId = packetId;
    }

    /** {@inheritDoc}
     * @see jpl.gds.evr.api.IEvr#getCategory(java.lang.String)
     * @return category or null
     */
    @Override
    public String getCategory(final String name) {
        if (evrDefinition == null) {
            return null;
        } else {
            return evrDefinition.getCategory(name);            
        }
    }
}
